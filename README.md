## Содержимое папок:

### "CSharpTestTask.Api" 
* классы и интерфейс для создения архивов.
* классы и интерфейс для распаковывания архивов.
* класс и интерфейс для ловли исключений.

### "CSharpTestTask.ConsoleApp" 
* **консольное приложение выполняющее задачи требуемы в задании.**

### "CSharpTestTask.DummyFileCreator" 
* консольное приложения и вспомогательные классы для создание тестовых файлов нужной величины и содержания.

### "CSharpTestTask.Tests" 
* проэкт для тестирования работы логики сжатия

### "GZipTest" 
* скомпелированный под win-64 в release режиме проэкт **"CSharpTestTask.ConsoleApp"** с файлом **"GZipTest.exe"**. Версия фреймворка **.NET Core 3.0**.

## Краткое описание логики архивирвания:
Метод Compress класса CompressCorrected создает один поток для считывания входнохо файла, второй поток для записи в выходной файл и несколько потоков для сжатия, колличество которых равно колличеству доступных ядер процессора. После считывания каждого блока его данные записываются в ConcurrentQueue и с помощью AutoResetEvent дается сигнал одному из потоков, отвечающему за сжатие обработать данный блок. Для синхронизации записи сжатого блока используется паттерн lock=>Monitor.Await=>Monitor.PulseAll. Записывающий поток ждет сигнала от сжимающих потоков о том что нужный блок готов к записи (AutorResetEvent) и посылает ответ, что блок записан (AutoResetEvent). После записи текущего блока, поток, который предоставил текущий блок отпускает lock  при помощи Monitor.PulseAll и увеличивает счетчик Semaphore, что дает сигнал для считывания следующего блока.

Формат файла архива: последовательность блоков, в первых четырех байтах которых записан размер данного блока и в следующих сам сжатий блок.
   
## Краткое описание логики распаковки:

Алгоритм распаковки такой же как и архивирвания, только в обратном порядке. Используется класс DecompressorCorrected.

   
   
