## Содержимое папок:

### "CSharpTestTask.Api" 
* классы и интерфейс для создения архивов.
* классы и интерфейс для распаковывания архивов.
* класс и интерфейс для ловли исключений.

### "CSharpTestTask.ConsoleApp" 
* **консольное приложение выполняющее задачи требуемы в задании.**

### "CSharpTestTask.DummyFileCreator" 
* консольное приложения и вспомогательные классы для создание тестовых файлов нужной величины и содержания.

### "CSharpTestTask.Tests" 
* проэкт для тестирования работы логики сжатия

### "GZipTest" 
* скомпелированный под win-64 в release режиме проэкт **"CSharpTestTask.ConsoleApp"** с файлом **"GZipTest.exe"**. Версия фреймворка **.NET Core 3.0**.

## Краткое описание логики сжатия:

   Сжатие начинается создением выходного файла с шапкoй в которую записывается колличество блоков (int32) на которe будет разделятся архивируемый файл, размер блоков (int32) и размер исходного файла (int64). Далее идет пустая область размером в колличество блоков \* 4 байт в которой будут хранится размеры сжатых блоков.
   
   Создается нужное колличество потоков каждый из которых берет номер следующей части для сжатия и сжимает ее. В шапку выходного файла записывается колличество байт в сжатом блоке и в конце добавляются сами сжатые байты. Каждый поток рекурсивно берет номер следующего блока и обрабатывает его, пока они не закончатся.
   
   Запись в выходной файл производится с синхронизацией потоков - потоки записывают сжатые байты в порядке очереди. Я попробовал два метода синхронизации потоков - с помощью SpinWait.SpinUntil и через паттерн Lock -> Monitor.Wait -> Monitor.Pulse. Оба вроде бы робочие и сохранены в отдельных файлах в папке **"CSharpTestTask.Api/Compressors"**. 
   
## Краткое описание логики распаковки:

  Распаковка начинается считыванием шапки архива.  Данные о частях, которые нужно распаковать записываются в ConcurrentQueue. Создается выходной файл нужного размера, нужное колличество потоков которые рекурсивно записывают блоки в выходной файл на основе данных из входного и информации, записанной в ConcurrentQueue. 
   
   
